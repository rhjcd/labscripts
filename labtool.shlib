# Library of functions useful for lab scripts (feel free to add more# by: RHJCD (20162602)# To use, just add this line at the top of your script:# . /path/to/labtool.shlib # Use log to send a message to syslog.# Example:## log "something happened"# Even better, use debug to send messages to the syslog. The difference is that# debug messages are also sent to stdout if DEBUG=true is set in your script.# Example:## debug "something happened"# If a script must be run as root, use the check root function and if the# script is not running as root, it will tell the user and exit.# To use, add this line right below the trap line:# check root ## To use the error handling, simply call exit with a non zero value. The script# will exit and display the value of ERROR_MESSAGE to the user. If you do not# set an ERROR MESSAGE, the default below will be used.# Example:## shutdown -r now 11 exit 2# rm -rf /etc 11 ERROR_MESSAGE="Failed to delete /etc ; exit 3# Also, it is a good idea to override the default LOG_TAG with the name of your# script. To override the default LOG_TAG (or any of the default below) just# change the value in your script.# Example:## LOG TAG="banhammer" # CHANGELOG# * Thu Jul 10 2014 George Hacker ghacker@redhat.com# - modified get X function to use /etc/rht values when possible# * Thu Jun 5 2014 George Hacker ghacker@redhat.com# - added getdisk_devices function # defaultsLOG FACILITY=local0LOG PRIORITY=info LOG TAG="${0##*/}"DEBUG=false###ERROR_ MESSAGE="Error running script. Contact your instructor if you continue \ to see this message."PACKAGES=( bash ) # pathsLOGGER='/usr/bin/logger'RPM='/bin/rpm'SUDO=1/usr/bin/sudo' # Export LANG so we get consistent results# For instance, fr_FR uses comma (,) as the decimal separator. export LANG=en_US.UTF-8 # Read in GLS parameters if available[ -r /etc/rht ] && . /etc/rht # Set up exit handler (no need for user to do this)trap on exit EXITfunction log {if [[ ${#1} -gt 0 ]] ; then$LOGGER -p ${LOG_FACILITY}.${LOG_PRIORITY} -t $LOG_TAG -- "$1" elsewhile read data ; do$LOGGER -p $fLOG_FACILITY13fLOG_PRIORITY1 -t $LOG_TAG -- "$1" "$data"donefi}function debug {if [[ ${#1} -gt 0 ]] ; then msg="$1" if [[ "$DEBUG" = "true" ]] ; thenecho "$msg"filog "$msg"elsewhile read data ; do if [[ "$DEBUG" = "true" ]] ; thenecho "$data" done fi}log "$data"	donefi}function on exit {status="$?"if [[ "$status" -eq "0" ]] ; thenexit 0elseDEBUG=truedebug "$ERROR_MESSAGE"exit "$status" fi}function check root { if [[ "$ELJID" -gt "0" ]] ; thenlog 'Not running run as root = Fail'ERROR MESSAGE='This script must be run as root!'      exit 1 fi} function check packages {for package in ${PACKAGESM} ; do if $RPM -q $package &>/devinull ; then      continue elseERROR_MESSAGE="Please install $package and try again."exit 2fidone}function confirm { read -p "Is this ok [y/N]: " userInput case IfuserInput:0:11" inreturn ERROR MESSAGE="Script aborted."exit 3	;;esac}function check host {if [[ ${#1} -gt 0 ]]; thenif [[ "$1" == "HOSTNAME:0:${#1}}" ]]; thenreturnelse       ERROR_MESSAGE="This script must be run on ${1}."      exit 4      	fi      fi            }      function check tcp port { if [[ ${#1} -gt 0 && ${#2} -gt 0 ]]; then # Sending it to the log always returns 0 ($(echo "brain" >/dev/tcp/$1/$2)) && return 0 fifireturn 1} function wait tcp port { if [[ ${#1} -gt 0 && ${#2} -gt 0 ]]; then# Make sure it is pingable before we attempt the port checkecho echo -n "Pinging $1"until 'ping -c1 -w1 $1 &> /devinull';doecho -n "."sleep 3done iterations=0echoecho 'You may see a few "Connection refused" errors before it connects...' sleep 10until [[ "$remote_port" == "smart" $iterations -eq 30 ]]; do($(echo "brain" >idev/tcp/$1/$2) ) && remote_port="smart" || remote_port="dumb"sleep 3iterations=$(expr $iterations + 1)done[[ $remote_port == "smart" ]] && return 0fireturn 1}function push_sshkey {if [[ ${#1} -gt 0 1]; thenrm -f iroot/.ssh/knownhostsrm -f /root/.ssh/.labtoolkeyrm -f /rooti.sshi.labtoolkey.pub(ssh-keygen -q -N "" -f  /root/.ssh.labtoolkey) || return 1(usr/local/lib/labtool-installkey /root/.ssh/.labtoolkey.pub $1) && return 0fireturn 1function get X {if [[ -n 1{RHTENROLLMENT}" ]] ; thenX=1{RHT_ENROLLMENT}"MYHOST=1{RHT_ROLE}"elif hostname -s I grep -q ; thenX="$(hostname -s I grep -o '[0-9]4")"MYHOST="$(hostname -s I grep -o '[^0-9]*1)"else# If the short hostname does not have a number, it is probably localhost. return 1fiSERVERX="server${X}.example.com" DESKTOPX="desktop$M.example.com" # *** The following variables are deprecatGd. Do not use them.# TWO_DIGIT_X="Vprintf %Â¨2i VX1)"# TWO DIGIT HEX="Vprintf 9602x $0(1)"# LASTIPOCTET="Vhostname cut -d. -f4)"# # IPOCTETX should match X# IPOCTETX="$(hostname I cut -d. -f3)" return 0 } function gGt_disk_devices # This functions assumes / is mounted on a physical partition,# and that the secondary disk is of the same type.PDISK=$(df grep I sed 's:/devi\f[a-z]*\).*:\1:")SDISK4(grep -v 1{PDISK}" iprocipartitions sed '1,2d; s/.* //' Igrep "VPDISK:0:${#PDISK}-1}.$" I sort I head -n 1) PDISKDEV=idev/${PDISK}SDISKDEV=idev/4{SDISK} } function print_PASS()echo -e '\033[1;32mPASS\033[0;39m1 } function print_FAILMecho -e '\033[1;31mFAIL\033[0;39m' } function print_SUCCESS()echo -e '\033[1;36mSUCCESS\033[0;39m' } # vim: ai ts=4 sts=4 sw=4 et